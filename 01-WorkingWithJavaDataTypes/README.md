# Working with Java data types

## Use primitives and wrapper classes, including, operators, parentheses, type promotion and casting

### Primitive data types

| Data type | Size | Description|
| --- | --- | --- |
|`char`| 2 bytes | Stores a single character/letter or ASCII values |
|`byte`| 1 bytes | Stores whole numbers from -128 to 127 |
|`short`| 2 bytes | Stores whole numbers from -32,768 to 32,767 |
|`int`| 4 bytes | Stores whole numbers from -2,147,483,648 to 2,147,483,647 |
|`long`| 8 bytes | Stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |
|`float`| 4 bytes | Stores fractional numbers. Sufficient for storing 6 to 7 decimal digits |
|`double`| 8 bytes | Stores fractional numbers. Sufficient for storing 15 decimal digits |
|`boolean`| 1 bit | Stores true or false values |

Examples:

```java
char letter = 'a';
byte myByte = 100;
short myShort = 5000;
int myInt = 2548752;
long myLong = 45487841235754L; // The value must end with 'l' or 'L'
float myFloat = 1548.45478F; // The value must end with 'f' or 'F'
double myDouble = 5457.4578452121548D; // The value must end with 'd' or 'D'
boolean myBoolean = true; // false
```

#### Primitive number types are divided into two groups

**Integer types** stores whole numbers, positive or negative (such as 123 or -456), without decimals. Valid types are `byte`, `short`, `int` and `long`. Which type you should use, depends on the numeric value.

**Floating point types** represents numbers with a fractional part, containing one or more decimals. There are two types: `float` and `double`.

#### Use float or double?

The **precision** of a floating point value indicates how many digits the value can have after the decimal point. The precision of `float` is only six or seven decimal digits, while `double` variables have a precision of about 15 digits. Therefore it is safer to use `double` for most calculations.

#### Scientific Numbers

A floating point number can also be a scientific number with an "e" to indicate the power of 10:

```java
float f1 = 35e3f;
double d1 = 12E4d;
```

---

## Handle text using String and StringBuilder classes

### Strings

ref.: [What are the differences between String, StringBuffer and StringBuilder?][stringarticle]

`String`s in Java are objects used to represent a sequence of character. They can be either created using the `String` Literal or by using the `new` keyword.

```java
String text1 = "Some text";
String text2 = new String("Some text");
```

`String`s are immutable in Java are represented in the UTF-16 format. When a new `String` is created, it looks for the `String` with the same value in the [JVM string pool][stringpool]. If it finds a same value, then it returns the reference else it created a `String` object and places that object in the `String` pool.

Since `String`s are immutable in Java, whenever `String` manipulations are performed, automatically a new `String` would be generated by discarding the older one. But, don’t you think, this is cumbersome when we have large applications?

Well, to avoid garbage in heap, Java came up with `StringBuffer` and `StringBuilder`. So next in this article let us understand what are `StringBuffer` and `StringBuilder`.

### What are the differences between `StringBuffer` and `StringBuilder`?

`StringBuffer` and `StringBuilder` are classes used for `String` manipulation. These are mutable objects, which provide methods such as `substring()`, `insert()`, `append()`, `delete()` for `String` manipulation.

The main differences between StringBuffer and StringBuilder are as follows:

| `StringBuffer` | `StringBuilder` |
| --- | --- |
| `StringBuffer` operations are thread-safe and synchronized | `StringBuilder` operations are not thread-safe are not-synchronized. |
| `StringBuffer` is to used when multiple threads are working on the same `String` | `StringBuilder` is used in a single-threaded environment. |
| `StringBuffer` performance is slower when compared to `StringBuilder` | `StringBuilder` performance is faster when compared to `StringBuffer` |
| Syntax: `StringBuffer var = new StringBuffer(str);` | Syntax: `StringBuilder var = new StringBuilder(str);` |

### String vs StringBuilder vs StringBuffer in Java

The differences between String, StringBuffer, and StringBuilder are based on the following two parameters:

* Mutability
* Performance

#### Mutability

Well, when we compare the above terms, on the factor **Mutability**. Then, as mentioned before, `String`s are immutable while `StringBuffer` and `StringBuilder` are mutable. So, `String`s cannot be changed when you use the `String` class; whereas `String`s can change if you use the `StringBuffer` and `StringBuilder` class.

Consider the following code snippet:

```java
package edureka;
 
public class example {
     
    public static void StrConcat(String str1) 
    { 
        str1 = str1 + "Edureka"; 
    } 
   
    public static void StrBufConcat(StringBuffer str2) 
    { 
        str2.append("Edureka"); 
    } 
   
    public static void StrBuildConcat(StringBuilder str3) 
    { 
        str3.append("Edureka"); 
    } 
   
    public static void main(String[] args) 
    { 
        String str1 = "Hello!"; 
        StrConcat(str1); 
        System.out.println("The final String is - " + str1); 
   
        StringBuffer str2 = new StringBuffer("Hello!"); 
        StrBufConcat(str2); 
        System.out.println("The final String is - " + str2); 
   
        StringBuilder str3 = new StringBuilder("Hello!"); 
        StrBuildConcat(str3);
        System.out.println("The final String is -" + str3); 
    } 
} 
```

In the above code, I have three functions: `StrConcat`, `StrBufConcat`, and `StrBuildConcat`.

In the first function, I have passed a string -> “Hello!” and then to perform concatenation, I have used the + operator as [str1 = str1 + “Edureka”]. Now, if you observe the output, the String passed in the `main()` did not change, as String is immutable. This is because str1 in `main()` references to “Edureka” and str1 in `StrConcat()` references to a different object.

But, if you look at the other two functions: `StrBufConcat`, and `StrBuildConcat`; the output is the same as these objects are mutable. In the second and the third function, I have used the `append()` function to concatenate the `String`s.

#### Performance

`StringBuilder` is faster than `StringBuffer` as it offers no synchronization. This is because no extra overhead needs to be added to the system and also does not slows down the processing.

If I have to summarize the differences between `String`, `StringBuffer` and `StringBuilder`, then refer to the below table:

| Parameter | `String` | `StringBuffer` | `StringBuilder` |
| --- | --- | --- | --- |
| Storage | String Pool | Heap | Heap |
| Mutability | Immutable | Mutable | Mutable |
| Thread Safe| Not used in a threaded environment | Used in a multi-threaded environment | Used in a single-threaded environment |
| Performance | Slow | Slower than StringBuilder but faster than String | Faster than StringBuffer |
| Syntax | `String var =“Edureka”;` | `String var=new String(“Edureka”);` | `StringBuffer var = new StringBuffer("Edureka");` | `StringBuilder var = new StringBuilder("Edureka");` |

---

## Use local variable type inference, including as lambda parameters

[stringarticle]: https://www.edureka.co/blog/string-vs-stringbuffer-vs-stringbuilder/
[stringpool]: https://www.edureka.co/blog/java-string-pool/
