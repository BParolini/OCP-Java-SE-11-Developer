# Working with Java data types

## Use primitives and wrapper classes, including, operators, parentheses, type promotion and casting

### Primitive data types

| Data type | Size | Description|
| --- | --- | --- |
|`char`| 2 bytes | Stores a single character/letter or ASCII values |
|`byte`| 1 bytes | Stores whole numbers from -128 to 127 |
|`short`| 2 bytes | Stores whole numbers from -32,768 to 32,767 |
|`int`| 4 bytes | Stores whole numbers from -2,147,483,648 to 2,147,483,647 |
|`long`| 8 bytes | Stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 |
|`float`| 4 bytes | Stores fractional numbers. Sufficient for storing 6 to 7 decimal digits |
|`double`| 8 bytes | Stores fractional numbers. Sufficient for storing 15 decimal digits |
|`boolean`| 1 bit | Stores true or false values |

Examples:

```java
char letter = 'a';
byte myByte = 100;
short myShort = 5000;
int myInt = 2548752;
long myLong = 45487841235754L; // The value must end with 'l' or 'L'
float myFloat = 1548.45478F; // The value must end with 'f' or 'F'
double myDouble = 5457.4578452121548D; // The value must end with 'd' or 'D'
boolean myBoolean = true; // false
```

#### Primitive number types are divided into two groups

**Integer types** stores whole numbers, positive or negative (such as 123 or -456), without decimals. Valid types are `byte`, `short`, `int` and `long`. Which type you should use, depends on the numeric value.

**Floating point types** represents numbers with a fractional part, containing one or more decimals. There are two types: `float` and `double`.

#### Use float or double?

The **precision** of a floating point value indicates how many digits the value can have after the decimal point. The precision of `float` is only six or seven decimal digits, while `double` variables have a precision of about 15 digits. Therefore it is safer to use `double` for most calculations.

#### Scientific Numbers

A floating point number can also be a scientific number with an "e" to indicate the power of 10:

```java
float f1 = 35e3f;
double d1 = 12E4d;
```

---

## Handle text using String and StringBuilder classes

### Strings

ref.: [What are the differences between String, StringBuffer and StringBuilder?][stringarticle]

`String`s in Java are objects used to represent a sequence of character. They can be either created using the `String` Literal or by using the `new` keyword.

```java
String text1 = "Some text";
String text2 = new String("Some text");
```

`String`s are immutable in Java are represented in the UTF-16 format. When a new `String` is created, it looks for the `String` with the same value in the [JVM string pool][stringpool]. If it finds a same value, then it returns the reference else it created a `String` object and places that object in the `String` pool.

Since `String`s are immutable in Java, whenever `String` manipulations are performed, automatically a new `String` would be generated by discarding the older one. But, don’t you think, this is cumbersome when we have large applications?

Well, to avoid garbage in heap, Java came up with `StringBuffer` and `StringBuilder`. So next in this article let us understand what are `StringBuffer` and `StringBuilder`.

### What are the differences between `StringBuffer` and `StringBuilder`?

`StringBuffer` and `StringBuilder` are classes used for `String` manipulation. These are mutable objects, which provide methods such as `substring()`, `insert()`, `append()`, `delete()` for `String` manipulation.

The main differences between StringBuffer and StringBuilder are as follows:

| `StringBuffer` | `StringBuilder` |
| --- | --- |
| `StringBuffer` operations are thread-safe and synchronized | `StringBuilder` operations are not thread-safe are not-synchronized. |
| `StringBuffer` is to used when multiple threads are working on the same `String` | `StringBuilder` is used in a single-threaded environment. |
| `StringBuffer` performance is slower when compared to `StringBuilder` | `StringBuilder` performance is faster when compared to `StringBuffer` |
| Syntax: `StringBuffer var = new StringBuffer(str);` | Syntax: `StringBuilder var = new StringBuilder(str);` |

### String vs StringBuilder vs StringBuffer in Java

The differences between String, StringBuffer, and StringBuilder are based on the following two parameters:

* Mutability
* Performance

#### Mutability

Well, when we compare the above terms, on the factor **Mutability**. Then, as mentioned before, `String`s are immutable while `StringBuffer` and `StringBuilder` are mutable. So, `String`s cannot be changed when you use the `String` class; whereas `String`s can change if you use the `StringBuffer` and `StringBuilder` class.

Consider the following code snippet:

```java
package edureka;
 
public class example {
     
    public static void StrConcat(String str1) 
    { 
        str1 = str1 + "Edureka"; 
    } 
   
    public static void StrBufConcat(StringBuffer str2) 
    { 
        str2.append("Edureka"); 
    } 
   
    public static void StrBuildConcat(StringBuilder str3) 
    { 
        str3.append("Edureka"); 
    } 
   
    public static void main(String[] args) 
    { 
        String str1 = "Hello!"; 
        StrConcat(str1); 
        System.out.println("The final String is - " + str1); 
   
        StringBuffer str2 = new StringBuffer("Hello!"); 
        StrBufConcat(str2); 
        System.out.println("The final String is - " + str2); 
   
        StringBuilder str3 = new StringBuilder("Hello!"); 
        StrBuildConcat(str3);
        System.out.println("The final String is -" + str3); 
    } 
} 
```

In the above code, I have three functions: `StrConcat`, `StrBufConcat`, and `StrBuildConcat`.

In the first function, I have passed a string -> “Hello!” and then to perform concatenation, I have used the + operator as [str1 = str1 + “Edureka”]. Now, if you observe the output, the String passed in the `main()` did not change, as String is immutable. This is because str1 in `main()` references to “Edureka” and str1 in `StrConcat()` references to a different object.

But, if you look at the other two functions: `StrBufConcat`, and `StrBuildConcat`; the output is the same as these objects are mutable. In the second and the third function, I have used the `append()` function to concatenate the `String`s.

#### Performance

`StringBuilder` is faster than `StringBuffer` as it offers no synchronization. This is because no extra overhead needs to be added to the system and also does not slows down the processing.

If I have to summarize the differences between `String`, `StringBuffer` and `StringBuilder`, then refer to the below table:

| Parameter | `String` | `StringBuffer` | `StringBuilder` |
| --- | --- | --- | --- |
| Storage | String Pool | Heap | Heap |
| Mutability | Immutable | Mutable | Mutable |
| Thread Safe| Not used in a threaded environment | Used in a multi-threaded environment | Used in a single-threaded environment |
| Performance | Slow | Slower than StringBuilder but faster than String | Faster than StringBuffer |
| Syntax | `String var =“Edureka”;` | `String var=new String(“Edureka”);` | `StringBuffer var = new StringBuffer("Edureka");` | `StringBuilder var = new StringBuilder("Edureka");` |

---

## Use local variable type inference, including as lambda parameters

ref.: [Local Variable Type Inference][var]

In JDK 10 and later, you can declare local variables with non-null initializers with the var identifier, which can help you write code that’s easier to read.

Consider the following example, which seems redundant and is hard to read:

```java
URL url = new URL("http://www.oracle.com/"); 
URLConnection conn = url.openConnection(); 
Reader reader = new BufferedReader(
    new InputStreamReader(conn.getInputStream()));
```

You can rewrite this example by declaring the local variables with the var identifier. The type of the variables are inferred from the context:

```java
var url = new URL("http://www.oracle.com/"); 
var conn = url.openConnection(); 
var reader = new BufferedReader(
    new InputStreamReader(conn.getInputStream()));
```

`var` is a reserved type name, not a keyword, which means that existing code that uses `var` as a variable, method, or package name is not affected. However, code that uses `var` as a class or interface name is affected and the class or interface needs to be renamed.

`var` can be used for the following types of variables:

* Local variable declarations with initializers:

```java
var list = new ArrayList<String>();    // infers ArrayList<String>
var stream = list.stream();            // infers Stream<String>
var path = Paths.get(fileName);        // infers Path
var bytes = Files.readAllBytes(path);  // infers bytes[]
```

* Enhanced `for`-loop indexes:

```java
List<String> myList = Arrays.asList("a", "b", "c");
for (var element : myList) {...}  // infers String
```

* Index variables declared in traditional `for` loops:

```java
for (var counter = 0; counter < 10; counter++)  {...}   // infers int
```

* `try`-with-resources variable:

```java
try (var input = 
     new FileInputStream("validation.txt")) {...}   // infers FileInputStream
```

* Formal parameter declarations of implicitly typed lambda expressions: A lambda expression whose formal parameters have inferred types is _implicitly_ typed:

```java
BiFunction<Integer, Integer, Integer> = (a, b) -> a + b;
```

In JDK 11 and later, you can declare each formal parameter of an implicitly typed lambda expression with the `var` identifier:

```java
(var a, var b) -> a + b;
```

As a result, the syntax of a formal parameter declaration in an implicitly typed lambda expression is consistent with the syntax of a local variable declaration; applying the `var` identifier to each formal parameter in an implicitly typed lambda expression has the same effect as not using `var` at all.

You cannot mix inferred formal parameters and `var`-declared formal parameters in implicitly typed lambda expressions nor can you mix `var`-declared formal parameters and manifest types in explicitly typed lambda expressions. The following examples are not permitted:

```java
(var x, y) -> x.process(y)      // Cannot mix var and inferred formal parameters
                                // in implicitly typed lambda expressions
(var x, int y) -> x.process(y)  // Cannot mix var and manifest types
                                // in explicitly typed lambda expressions
```

### Local Variable Type Inference Style Guidelines

Local variable declarations can make code more readable by eliminating redundant information. However, it can also make code less readable by omitting useful information. Consequently, use this feature with judgment; no strict rule exists about when it should and shouldn't be used.

Local variable declarations don't exist in isolation; the surrounding code can affect or even overwhelm the effects of `var` declarations. [Style Guidelines for Local Variable Type Inference in Java][var-style-guide] examines the impact that surrounding code has on `var` declarations, explains tradeoffs between explicit and implicit type declarations, and provides guidelines for the effective use of `var` declarations.

---

[Index][index]  
[Next chapter][next]

[index]: ../README.md
[next]: ../02-JavaObject-OrientedApproach/README.md
[stringarticle]: https://www.edureka.co/blog/string-vs-stringbuffer-vs-stringbuilder/
[stringpool]: https://www.edureka.co/blog/java-string-pool/
[var]: https://docs.oracle.com/en/java/javase/11/language/local-variable-type-inference.html
[var-style-guide]: http://openjdk.java.net/projects/amber/LVTIstyle.html
